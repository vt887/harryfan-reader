# Name of this GitHub Actions workflow.
name: Semgrep CE scan

on:
  # Scan in PRs:
  pull_request: {}
  # Scan on-demand through GitHub Actions interface:
  workflow_dispatch: {}
  # Scan mainline branches and report all findings:
  push:
    branches:
      - '**'
  # Schedule the CI job (this method uses cron syntax):
  schedule:
    - cron: '0 15 * * *' # Run every day at 15:00 UTC, which is 00:00 JST.

permissions:
  contents: read
  security-events: write
  issues: write

jobs:
  semgrep:
    # User definable name of this GitHub Actions job.
    name: semgrep-oss/scan
    # If you are self-hosting, change the following `runs-on` value:
    runs-on: ubuntu-latest

    container:
      # A Docker image with Semgrep installed. Do not change this.
      image: semgrep/semgrep

    # Skip any PR created by dependabot to avoid permission issues:
    if: (github.actor != 'dependabot[bot]')

    steps:
      # Fetch project source with GitHub Actions Checkout. Use either v3 or v4.
      - uses: actions/checkout@v4

      # Print semgrep version for debugging / reproducibility.
      - name: Semgrep version
        run: |
          # semgrep v1+ uses `semgrep --version` or `semgrep scan --version` depending on the image
          if command -v semgrep >/dev/null 2>&1; then
            semgrep --version || semgrep scan --version || true
          else
            echo "semgrep not available"
          fi

      # Run the semgrep scan and produce machine-friendly outputs (JSON + SARIF).
      - id: semgrep-scan
        name: Run Semgrep (JSON & SARIF)
        run: |
          set -euo pipefail
          echo "Starting semgrep scan..."
          start_time=$(date +%s)

          # Run semgrep once for JSON and once for SARIF so both artifacts are available.
          # Use `|| true` to avoid exiting early if semgrep returns non-zero due to findings.
          semgrep scan --config auto --json > semgrep-results.json || true
          semgrep scan --config auto --sarif > semgrep-results.sarif || true

          end_time=$(date +%s)
          duration=$((end_time - start_time))
          echo "Semgrep scan finished in ${duration}s"

          # Export duration to subsequent steps in a GitHub Actions-friendly way.
          echo "semgrep_duration=${duration}" >> "$GITHUB_OUTPUT"

      # Upload semgrep artifacts so they can be inspected from the Actions run.
      - name: Upload Semgrep results
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: |
            semgrep-results.json
            semgrep-results.sarif

      # Upload SARIF to GitHub Code Scanning (adds the findings to the repository's code scanning alerts).
      - name: Upload SARIF to GitHub code scanning
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: semgrep-results.sarif

      # Short human-readable summary printed to the job log. We don't parse the JSON here
      # to keep the step portable across runner images.
      - name: Semgrep quick note
        run: |
          echo "Semgrep scan completed (duration: ${{ steps.semgrep-scan.outputs.semgrep_duration }}s)"
          if [ -f semgrep-results.json ]; then
            echo "semgrep-results.json saved (size: $(du -sh semgrep-results.json | cut -f1))"
          fi
          if [ -f semgrep-results.sarif ]; then
            echo "semgrep-results.sarif saved (size: $(du -sh semgrep-results.sarif | cut -f1))"
          fi

      # Generate PR comment body from template and semgrep outputs (only run on PRs).
      - id: generate-comment
        name: Generate PR comment body
        if: github.event_name == 'pull_request'
        run: |
          set -euo pipefail
          # Compute basic metrics from semgrep JSON when available.
          findings=0
          if [ -f semgrep-results.json ]; then
            # Use a small python one-liner to count results (avoids requiring jq in container)
            findings=$(python3 -c "import json,sys
try:
    print(len(json.load(open('semgrep-results.json')).get('results', [])))
except Exception:
    print(0)
" 2>/dev/null || echo 0)
          fi

          # Fallbacks / best-effort values
          blocking=0
          rules_run="N/A"
          # Count git-tracked files as an approximation of files scanned by default.
          files_scanned=$(git ls-files | wc -l | tr -d ' ')
          parsed_lines="N/A"
          skipped_files="N/A"
          duration="${{ steps.semgrep-scan.outputs.semgrep_duration }}s"
          semgrep_version=$(semgrep --version || semgrep scan --version || echo "unknown")
          artifact_json_link="Artifact 'semgrep-results' attached to this workflow run"
          sarif_status="Uploaded to Code Scanning (if permitted)"

          # Export environment variables for the filler
          export FINDINGS="$findings"
          export BLOCKING="$blocking"
          export RULES_RUN="$rules_run"
          export FILES_SCANNED="$files_scanned"
          export PARSED_LINES="$parsed_lines"
          export SKIPPED_FILES="$skipped_files"
          export DURATION="$duration"
          export SEMGREP_VERSION="$semgrep_version"
          export ARTIFACT_JSON_LINK="$artifact_json_link"
          export SARIF_STATUS="$sarif_status"

          # Fill the template using awk (safer inside YAML run blocks than heredocs)
          awk '
          { l = $0
            gsub(/{{findings}}/, ENVIRON["FINDINGS"], l)
            gsub(/{{blocking}}/, ENVIRON["BLOCKING"], l)
            gsub(/{{rules_run}}/, ENVIRON["RULES_RUN"], l)
            gsub(/{{files_scanned}}/, ENVIRON["FILES_SCANNED"], l)
            gsub(/{{parsed_lines}}/, ENVIRON["PARSED_LINES"], l)
            gsub(/{{skipped_files}}/, ENVIRON["SKIPPED_FILES"], l)
            gsub(/{{duration}}/, ENVIRON["DURATION"], l)
            gsub(/{{semgrep_version}}/, ENVIRON["SEMGREP_VERSION"], l)
            gsub(/{{artifact_json_link}}/, ENVIRON["ARTIFACT_JSON_LINK"], l)
            gsub(/{{sarif_status}}/, ENVIRON["SARIF_STATUS"], l)
            print l
          }' .github/semgrep/scan-summary-template.md > comment-body.md

          echo "Comment body generated at $(pwd)/comment-body.md"

      # Post or update a PR comment with the generated body (only on PRs).
      - name: Post or update PR comment
        if: github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.pull_request.number }}
          body-file: comment-body.md
